<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- iOS Safari: prevent zoom + safe-area support -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Gizmo’s Table Scraps — 16-bit</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      height: 100%;
      margin: 0;
      background: #05060a;
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none;
      -webkit-text-size-adjust: 100%;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      touch-action: none;
    }

    /* Mobile controls (backup if tilt permission denied) */
    #mobileControls {
      position: fixed;
      left: 0; right: 0;
      bottom: calc(10px + env(safe-area-inset-bottom));
      display: none;
      justify-content: space-between;
      gap: 10px;
      padding: 0 12px;
      pointer-events: none;
    }
    .pad, .actions { display:flex; gap:10px; pointer-events:auto; }
    .btn {
      -webkit-tap-highlight-color: transparent;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.40);
      color: rgba(255,255,255,.92);
      font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-weight: 900;
      border-radius: 14px;
      padding: 14px 14px;
      min-width: 64px;
      text-align: center;
      touch-action: none;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.38);
    }
    .btn:active { transform: translateY(1px); }
    .btn.small { min-width: 56px; padding: 12px 12px; }
    .btn.wide { min-width: 90px; }

    @media (pointer: coarse), (max-width: 820px) {
      #mobileControls { display: flex; }
    }
  </style>
</head>
<body>
  <canvas id="screen"></canvas>

  <div id="mobileControls" aria-label="Mobile controls">
    <div class="pad">
      <div class="btn" data-act="left">◀</div>
      <div class="btn" data-act="right">▶</div>
    </div>
    <div class="actions">
      <div class="btn wide" data-act="cal">CAL</div>
      <div class="btn wide" data-act="dash">DASH</div>
      <div class="btn small" data-act="pause">⏯</div>
    </div>
  </div>

<script>
(() => {
  // ================= iOS SAFARI: BLOCK DOUBLE-TAP / PINCH ZOOM =================
  document.addEventListener('dblclick', (e) => e.preventDefault(), { passive:false });
  ['gesturestart','gesturechange','gestureend'].forEach(evt =>
    document.addEventListener(evt, (e) => e.preventDefault(), { passive:false })
  );
  let __lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const t = Date.now();
    if (t - __lastTouchEnd <= 300) e.preventDefault();
    __lastTouchEnd = t;
  }, { passive:false });

  // ================= CANVAS / PIXEL BUFFER =================
  const screen = document.getElementById('screen');
  const sctx = screen.getContext('2d', { alpha: false });

  const buf = document.createElement('canvas');
  const bctx = buf.getContext('2d', { alpha: true });

  const isCoarse = window.matchMedia("(pointer: coarse)").matches;

  // Important fix: do NOT force a minimum integer scale that would overflow width on portrait phones.
  // Instead, adapt buffer width for portrait and allow scale=1 if needed.
  const BASE_H = 190; // slightly taller for cleaner HUD/layout
  let BW = 320, BH = BASE_H;
  let scale = 2, ox = 0, oy = 0;

  function clampInt(v, a, b){ return Math.max(a, Math.min(b, v|0)); }

  function resize() {
    const W = window.innerWidth;
    const H = window.innerHeight;

    screen.width  = Math.floor(W * devicePixelRatio);
    screen.height = Math.floor(H * devicePixelRatio);
    sctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

    BH = BASE_H;

    const aspect = W / H;
    const idealW = Math.round(BH * aspect);

    // Portrait phones need a narrower buffer so scale can be >=2 without cropping.
    const minW = isCoarse ? 160 : 240;
    const maxW = isCoarse ? 420 : 560;
    BW = clampInt(idealW, minW, maxW);

    buf.width = BW;
    buf.height = BH;

    const fit = Math.min(W / BW, H / BH);
    scale = Math.max(1, Math.floor(fit)); // allow 1 if necessary (prevents cropping)
    const rw = BW * scale;
    const rh = BH * scale;

    ox = Math.floor((W - rw) / 2);
    oy = Math.floor((H - rh) / 2);

    sctx.imageSmoothingEnabled = false;
    bctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', resize);
  resize();

  // ================= UTIL =================
  const rand  = (a,b) => a + Math.random()*(b-a);
  const randi = (a,b) => Math.floor(rand(a,b+1));
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const now   = () => performance.now();

  function pxFill(x,y,w,h,c){
    bctx.fillStyle=c;
    bctx.fillRect(x|0,y|0,w|0,h|0);
  }

  // ✅ ADD THIS
  function outlineRect(x, y, w, h, c) {
    x |= 0; y |= 0; w |= 0; h |= 0;
    if (w <= 0 || h <= 0) return;
    pxFill(x, y, w, 1, c);           // top
    pxFill(x, y + h - 1, w, 1, c);   // bottom
    pxFill(x, y, 1, h, c);           // left
    pxFill(x + w - 1, y, 1, h, c);   // right
  }

  // ================= 5x7 BITMAP FONT (FIXES ALIGNMENT RELIABLY) =================
  // All UI text is rendered via this font (no browser font metrics => no misalignment).
  const FONT = {
    'A':[0b01110,0b10001,0b10001,0b11111,0b10001,0b10001,0b10001],
    'B':[0b11110,0b10001,0b10001,0b11110,0b10001,0b10001,0b11110],
    'C':[0b01111,0b10000,0b10000,0b10000,0b10000,0b10000,0b01111],
    'D':[0b11110,0b10001,0b10001,0b10001,0b10001,0b10001,0b11110],
    'E':[0b11111,0b10000,0b10000,0b11110,0b10000,0b10000,0b11111],
    'F':[0b11111,0b10000,0b10000,0b11110,0b10000,0b10000,0b10000],
    'G':[0b01111,0b10000,0b10000,0b10111,0b10001,0b10001,0b01111],
    'H':[0b10001,0b10001,0b10001,0b11111,0b10001,0b10001,0b10001],
    'I':[0b11111,0b00100,0b00100,0b00100,0b00100,0b00100,0b11111],
    'J':[0b00111,0b00010,0b00010,0b00010,0b10010,0b10010,0b01100],
    'K':[0b10001,0b10010,0b10100,0b11000,0b10100,0b10010,0b10001],
    'L':[0b10000,0b10000,0b10000,0b10000,0b10000,0b10000,0b11111],
    'M':[0b10001,0b11011,0b10101,0b10101,0b10001,0b10001,0b10001],
    'N':[0b10001,0b11001,0b10101,0b10011,0b10001,0b10001,0b10001],
    'O':[0b01110,0b10001,0b10001,0b10001,0b10001,0b10001,0b01110],
    'P':[0b11110,0b10001,0b10001,0b11110,0b10000,0b10000,0b10000],
    'Q':[0b01110,0b10001,0b10001,0b10001,0b10101,0b10010,0b01101],
    'R':[0b11110,0b10001,0b10001,0b11110,0b10100,0b10010,0b10001],
    'S':[0b01111,0b10000,0b10000,0b01110,0b00001,0b00001,0b11110],
    'T':[0b11111,0b00100,0b00100,0b00100,0b00100,0b00100,0b00100],
    'U':[0b10001,0b10001,0b10001,0b10001,0b10001,0b10001,0b01110],
    'V':[0b10001,0b10001,0b10001,0b10001,0b10001,0b01010,0b00100],
    'W':[0b10001,0b10001,0b10001,0b10101,0b10101,0b10101,0b01010],
    'X':[0b10001,0b10001,0b01010,0b00100,0b01010,0b10001,0b10001],
    'Y':[0b10001,0b10001,0b01010,0b00100,0b00100,0b00100,0b00100],
    'Z':[0b11111,0b00001,0b00010,0b00100,0b01000,0b10000,0b11111],
    '0':[0b01110,0b10001,0b10011,0b10101,0b11001,0b10001,0b01110],
    '1':[0b00100,0b01100,0b00100,0b00100,0b00100,0b00100,0b01110],
    '2':[0b01110,0b10001,0b00001,0b00010,0b00100,0b01000,0b11111],
    '3':[0b11110,0b00001,0b00001,0b01110,0b00001,0b00001,0b11110],
    '4':[0b00010,0b00110,0b01010,0b10010,0b11111,0b00010,0b00010],
    '5':[0b11111,0b10000,0b10000,0b11110,0b00001,0b00001,0b11110],
    '6':[0b01110,0b10000,0b10000,0b11110,0b10001,0b10001,0b01110],
    '7':[0b11111,0b00001,0b00010,0b00100,0b01000,0b01000,0b01000],
    '8':[0b01110,0b10001,0b10001,0b01110,0b10001,0b10001,0b01110],
    '9':[0b01110,0b10001,0b10001,0b01111,0b00001,0b00001,0b01110],
    ' ':[0,0,0,0,0,0,0],
    ':':[0,0b00100,0,0,0b00100,0,0],
    '.':[0,0,0,0,0,0b00100,0b00100],
    ',':[0,0,0,0,0,0b00100,0b01000],
    '%':[0b11001,0b11010,0b00100,0b01000,0b10110,0b00110,0],
    '!':[0b00100,0b00100,0b00100,0b00100,0,0b00100,0],
    '?':[0b01110,0b10001,0b00001,0b00010,0b00100,0,0b00100],
    '-':[0,0,0,0b11111,0,0,0],
    '/':[0b00001,0b00010,0b00100,0b01000,0b10000,0,0],
    '\'':[0b00100,0b00100,0,0,0,0,0],
    '+':[0,0b00100,0b00100,0b11111,0b00100,0b00100,0],
    '(':[0b00010,0b00100,0b01000,0b01000,0b01000,0b00100,0b00010],
    ')':[0b01000,0b00100,0b00010,0b00010,0b00010,0b00100,0b01000],
  };

  const CHAR_W = 6; // 5 pixels + 1 spacing
  const CHAR_H = 8; // 7 pixels + 1 spacing

  function textWidthPx(str, scale=1){
    return (str.length * CHAR_W - 1) * scale;
  }

  function drawText(str, x, y, color, scale=1, shadow=false, shadowColor='rgba(0,0,0,0.45)'){
    str = String(str).toUpperCase();
    const drawOne = (ox, oy, col) => {
      let cx = ox;
      for (let i=0;i<str.length;i++){
        const ch = str[i];
        const rows = FONT[ch] || FONT['?'];
        for (let r=0;r<7;r++){
          const bits = rows[r] || 0;
          for (let c=0;c<5;c++){
            if (bits & (1 << (4 - c))) {
              pxFill(cx + c*scale, oy + r*scale, scale, scale, col);
            }
          }
        }
        cx += CHAR_W * scale;
      }
    };
    if (shadow) drawOne((x+scale)|0, (y+scale)|0, shadowColor);
    drawOne(x|0, y|0, color);
  }

  function wrapByPixels(str, maxPx, scale=1){
    str = String(str).toUpperCase();
    const words = str.split(/\s+/);
    const lines = [];
    let line = '';
    for (const w of words) {
      const cand = line ? (line + ' ' + w) : w;
      if (textWidthPx(cand, scale) <= maxPx) { line = cand; continue; }
      if (line) lines.push(line);
      // Hard split long word
      if (textWidthPx(w, scale) > maxPx) {
        let chunk = '';
        for (const ch of w) {
          const cc = chunk + ch;
          if (textWidthPx(cc, scale) <= maxPx) chunk = cc;
          else { lines.push(chunk); chunk = ch; }
        }
        line = chunk;
      } else {
        line = w;
      }
    }
    if (line) lines.push(line);
    return lines;
  }

  // ================= AUDIO =================
  const Audio = {
    ctx: null,
    master: null,
    gain: 0.45,
    muted: false,
    musicOn: true,
    music: { nextT: 0, step: 0, isActive: false },

    ensure() {
      if (this.ctx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return;
      this.ctx = new Ctx();
      this.master = this.ctx.createGain();
      this.master.gain.value = this.muted ? 0 : this.gain;
      this.master.connect(this.ctx.destination);
    },
    resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
    setMute(v) { this.muted = v; if (this.master) this.master.gain.value = v ? 0 : this.gain; },

    beep({freq=440, dur=0.08, type='square', vol=0.7, attack=0.005, decay=0.06, slide=0} = {}) {
      if (!this.ctx || !this.master) return;
      const t0 = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;

      const f0 = Math.max(40, freq);
      o.frequency.setValueAtTime(f0, t0);
      if (slide !== 0) o.frequency.exponentialRampToValueAtTime(Math.max(40, f0 + slide), t0 + dur);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.linearRampToValueAtTime(vol, t0 + attack);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + attack + decay);

      o.connect(g); g.connect(this.master);
      o.start(t0); o.stop(t0 + dur + 0.02);
    },
    chord(freqs, dur=0.12, type='square', vol=0.15) {
      for (let i=0;i<freqs.length;i++){
        this.beep({freq: freqs[i], dur, type, vol, attack:0.003, decay:dur*0.85});
      }
    },
    sfx(name) {
      if (!this.ctx) return;
      switch (name) {
        case 'start': this.beep({freq:660, dur:0.07, type:'square', vol:0.55, slide:120}); break;
        case 'pause': this.beep({freq:330, dur:0.07, type:'square', vol:0.45, slide:-60}); break;
        case 'catch': this.beep({freq:880, dur:0.06, type:'square', vol:0.50, slide:80}); break;
        case 'bonus': this.chord([523.25, 659.25, 783.99], 0.10, 'square', 0.13); break;
        case 'power': this.beep({freq:440, dur:0.10, type:'triangle', vol:0.50, slide:440}); break;
        case 'bad':   this.chord([220, 233.08, 246.94], 0.10, 'sawtooth', 0.10); break;
        case 'miss':  this.beep({freq:210, dur:0.07, type:'triangle', vol:0.28, slide:-90}); break;
        case 'dash':  this.beep({freq:520, dur:0.06, type:'square', vol:0.35, slide:260}); break;
        case 'slurp': this.beep({freq:250, dur:0.14, type:'triangle', vol:0.45, slide:700}); break;
        case 'danger':this.beep({freq:180, dur:0.12, type:'sawtooth', vol:0.22, slide:-30}); break;
        case 'gameover':
          this.beep({freq:392, dur:0.10, type:'triangle', vol:0.40, slide:-120});
          setTimeout(()=>this.beep({freq:330, dur:0.10, type:'triangle', vol:0.36, slide:-120}), 90);
          setTimeout(()=>this.beep({freq:262, dur:0.16, type:'triangle', vol:0.34, slide:-80}), 180);
          break;
      }
    },

    startMusic() { if (!this.ctx) return; this.music.isActive = true; this.music.nextT = Math.max(this.music.nextT, this.ctx.currentTime + 0.03); },
    stopMusic()  { this.music.isActive = false; },

    tickMusic(active) {
      if (!this.ctx || !this.master) return;
      if (!this.musicOn || !active) return;
      if (!this.music.isActive) this.startMusic();

      const stepDur = 0.125;
      const lookAhead = 0.20;

      // slightly richer "16-bit kitchen loop"
      const pattern = [
        440, 523.25, 659.25, 523.25,
        392, 493.88, 587.33, 493.88,
        349.23, 440, 523.25, 440,
        392, 440, 493.88, 440
      ];
      const bass = [
        110, 0, 0, 0,
        98,  0, 0, 0,
        87.31,0,0,0,
        98,  0, 0, 0
      ];

      while (this.music.nextT < this.ctx.currentTime + lookAhead) {
        const i = this.music.step % pattern.length;
        const f = pattern[i];
        const b = bass[i];

        if (f) {
          const t0 = this.music.nextT;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = 'square';
          o.frequency.setValueAtTime(f, t0);
          g.gain.setValueAtTime(0.0001, t0);
          g.gain.linearRampToValueAtTime(0.11, t0 + 0.004);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + stepDur * 0.92);
          o.connect(g); g.connect(this.master);
          o.start(t0); o.stop(t0 + stepDur);
        }
        if (b) {
          const t0 = this.music.nextT;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = 'triangle';
          o.frequency.setValueAtTime(b, t0);
          g.gain.setValueAtTime(0.0001, t0);
          g.gain.linearRampToValueAtTime(0.07, t0 + 0.004);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + stepDur * 0.95);
          o.connect(g); g.connect(this.master);
          o.start(t0); o.stop(t0 + stepDur);
        }

        this.music.step++;
        this.music.nextT += stepDur;
      }
    }
  };

  function unlockAudioOnce(){ Audio.ensure(); Audio.resume(); }

  // ================= WORLD =================
  const world = {
    tableY: 50,
    tableTopH: 12,
    tableLipH: 6,
    floorY: () => BH - 22,
    left: () => 10,
    right: () => BW - 10,
  };

  // ================= INPUT (TILT + TAP-TO-SLURP) =================
  const input = {
    left:false, right:false, dash:false,
    slurpQueued:false,
  };

  // Tilt
  const tilt = {
    supported: !!window.DeviceOrientationEvent,
    enabled: false,
    requested: false,
    zeroSet: false,
    zero: 0,
    raw: 0,
    smooth: 0
  };

  function orientationAngle(){
    if (screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
    if (typeof window.orientation === 'number') return window.orientation;
    return 0;
  }

  function onDeviceOrientation(e){
    if (e.gamma == null && e.beta == null) return;
    const ang = orientationAngle();
    let lr;
    if (ang === 0) lr = e.gamma;
    else if (ang === 180) lr = -e.gamma;
    else if (ang === 90) lr = -e.beta;
    else if (ang === -90 || ang === 270) lr = e.beta;
    else lr = e.gamma;

    if (!tilt.zeroSet) { tilt.zero = lr || 0; tilt.zeroSet = true; }
    tilt.raw = (lr || 0) - tilt.zero;
    tilt.smooth = tilt.smooth * 0.86 + tilt.raw * 0.14;
  }

  function enableTilt(){
    if (tilt.enabled) return;
    tilt.enabled = true;
    tilt.zeroSet = false;
    tilt.smooth = 0;
    window.addEventListener('deviceorientation', onDeviceOrientation, true);
  }

  async function requestTiltPermissionOnce(){
    if (!isCoarse) return;
    if (!tilt.supported || tilt.requested) return;
    tilt.requested = true;
    try {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res === 'granted') enableTilt();
      } else {
        enableTilt();
      }
    } catch (_) {}
  }

  function calibrateTilt(){
    if (!tilt.enabled) return;
    tilt.zeroSet = false;
  }

  // ================= GAME STATE =================
  const state = {
    phase: 'title', // 'title' | 'playing' | 'paused' | 'gameover'
    lastT: now(),
    tAlive: 0,

    score: 0,
    best: 0,
    streak: 0,
    caught: 0,
    missed: 0,

    starving: 35, // 0..100
    dangerPulseT: 0,
    level: 1,

    scraps: [],
    particles: [],
    floaters: [],

    magnetTime: 0,
    slowTime: 0,

    dashTime: 0,
    dashCooldown: 0,

    slurpTime: 0,
    slurpCooldown: 0,
    slurpVfx: 0,
    scanT: 0
  };

  // ================= GIZMO SPRITE (IMPROVED: 2-FRAME WIGGLE) =================
  const gizmo = { x: 160, y: 0, vx: 0, speed: 235, mouth: 0, bob: 0, step: 0 };

  function resetGizmo(){
    gizmo.x = Math.floor(BW/2);
    gizmo.y = world.floorY() - 14;
    gizmo.vx = 0;
    gizmo.mouth = 0;
    gizmo.bob = 0;
    gizmo.step = 0;
  }
  resetGizmo();

  function drawGizmo(){
    const x = gizmo.x|0, y = gizmo.y|0;
    const bob = Math.round(Math.sin(gizmo.bob)*1);
    const run = (Math.abs(gizmo.vx) > 15) ? (Math.floor(gizmo.step) % 2) : 0;

    // shadow
    pxFill(x-12, world.floorY()+4, 24, 3, 'rgba(0,0,0,0.35)');

    // body
    pxFill(x-13, y+6+bob, 26, 9, '#0b0e16');
    pxFill(x-11, y+5+bob, 22, 2, '#131a2a');

    // legs (run cycle)
    const legY = y+14+bob;
    if (run === 0) {
      pxFill(x-10, legY, 4, 2, '#070a10');
      pxFill(x-1,  legY, 4, 2, '#070a10');
      pxFill(x+7,  legY, 4, 2, '#070a10');
    } else {
      pxFill(x-8,  legY, 4, 2, '#070a10');
      pxFill(x+1,  legY, 4, 2, '#070a10');
      pxFill(x+6,  legY, 4, 2, '#070a10');
    }

    // head
    pxFill(x-11, y-2+bob, 22, 13, '#0a0d15');
    pxFill(x-9,  y-1+bob, 18, 2,  '#101b33');

    // ears
    pxFill(x-13, y-3+bob, 6, 7, '#070a10');
    pxFill(x+7,  y-3+bob, 6, 7, '#070a10');

    // snout
    pxFill(x-6, y+5+bob, 12, 6, '#070911');

    // eyes (white + pupil + shine)
    pxFill(x-7, y+2+bob, 4, 4, '#eaf6ff');
    pxFill(x+3, y+2+bob, 4, 4, '#eaf6ff');
    pxFill(x-6, y+3+bob, 2, 2, '#1b4a7a');
    pxFill(x+4, y+3+bob, 2, 2, '#1b4a7a');
    pxFill(x-6, y+2+bob, 1, 1, '#ffffff');
    pxFill(x+4, y+2+bob, 1, 1, '#ffffff');

    // nose
    pxFill(x-2, y+6+bob, 4, 2, '#020205');

    // mouth
    pxFill(x-4, y+8+bob, 8, 1, 'rgba(255,255,255,0.20)');
    if (gizmo.mouth > 0.02) {
      pxFill(x-2, y+9+bob, 4, 1, '#ff6aa6');
      pxFill(x-4, y+10+bob, 8, 1, '#05060a');
    }

    // collar + tag
    pxFill(x-11, y+11+bob, 22, 2, '#c0182b');
    pxFill(x-2,  y+11+bob, 4, 2, '#ffd35a');
  }

  // ================= FUNNY FOOD TYPES (BETTER OUTLINES) =================
  // base: score points, feed: lowers starving (negative raises starving)
  const FoodTypes = [
    { name:'COUCH FRY', base: 14, feed: 12, rarity: 1.00, draw:(x,y)=>{
      pxFill(x-4,y-4,8,8,'rgba(0,0,0,0.20)');
      pxFill(x-4,y-3,8,7,'#4a2e18');
      pxFill(x-3,y-5,1,9,'#ffd35a'); pxFill(x-1,y-5,1,9,'#ffd35a'); pxFill(x+1,y-5,1,9,'#ffd35a');
      pxFill(x-2,y-4,1,7,'#fff2b0'); pxFill(x,y-4,1,7,'#fff2b0'); pxFill(x+2,y-4,1,7,'#fff2b0');
    }},
    { name:'NACHO SHARD', base: 11, feed: 9,  rarity: 1.00, draw:(x,y)=>{
      pxFill(x-5,y-2,10,5,'#b36b1f');
      pxFill(x-4,y-3,8,1,'#ffdca0');
      pxFill(x-4,y-2,8,4,'#ffcf4d');
      pxFill(x-1,y,2,1,'#e58f2a');
      pxFill(x-2,y-1,1,1,'#fff2b0');
    }},
    { name:'HALF TACO', base: 18, feed: 16, rarity: 0.85, draw:(x,y)=>{
      pxFill(x-6,y-2,12,5,'#8a4b1e');
      pxFill(x-5,y-2,10,4,'#c77a22');
      pxFill(x-4,y-1,8,2,'#2bdc74');
      pxFill(x-2,y-1,4,1,'#ff6aa6');
      pxFill(x+3,y-1,1,1,'#fff2b0');
    }},
    { name:'MEATBALL?', base: 16, feed: 13, rarity: 0.90, draw:(x,y)=>{
      pxFill(x-5,y-5,10,10,'#3a1f12');
      pxFill(x-4,y-4,8,8,'#a14f2a');
      pxFill(x-2,y-2,2,2,'#d28a5e');
      pxFill(x+1,y,1,1,'#ffdca0');
    }},
    { name:'FLOOR GRAPE', base: 9, feed: 7, rarity: 1.00, draw:(x,y)=>{
      pxFill(x-5,y-5,10,10,'#241043');
      pxFill(x-4,y-4,8,8,'#7a3bd1');
      pxFill(x-2,y-2,2,2,'#c9a2ff');
      pxFill(x+1,y-1,1,1,'#ffffff');
    }},
    { name:'WET LETTUCE', base: 6, feed: 9, rarity: 0.95, draw:(x,y)=>{
      pxFill(x-5,y-4,10,8,'#0e2a18');
      pxFill(x-4,y-3,8,6,'#1fbf5f');
      pxFill(x-2,y-2,2,2,'#56ff96');
      pxFill(x+1,y+1,2,1,'#128a44');
    }},
    { name:'ONION PORTAL', base: 22, feed: 10, rarity: 0.50, onCatch:()=>{ state.magnetTime = 5.0; Audio.sfx('power'); }, draw:(x,y)=>{
      pxFill(x-6,y-6,12,12,'#25170c');
      pxFill(x-5,y-5,10,10,'#d7a52b');
      pxFill(x-3,y-3,6,6,'#05060a');
      pxFill(x-4,y-4,8,1,'#fff2b0');
      pxFill(x-1,y-6,2,1,'#56ff96');
    }},
    { name:'ICE OF TIME', base: 10, feed: 8, rarity: 0.38, onCatch:()=>{ state.slowTime = 5.0; Audio.sfx('power'); }, draw:(x,y)=>{
      pxFill(x-5,y-5,10,10,'#0a2a3a');
      pxFill(x-4,y-4,8,8,'#89d6ff');
      pxFill(x-3,y-3,6,6,'#c9f0ff');
      pxFill(x-2,y-2,4,4,'#89d6ff');
      pxFill(x-4,y-4,1,1,'#ffffff');
    }},
    { name:'STEAK (GOLD)', base: 55, feed: 12, rarity: 0.16, onCatch:()=>{ state.magnetTime = 7.0; Audio.sfx('power'); }, draw:(x,y)=>{
      pxFill(x-6,y-4,12,8,'#4a260d');
      pxFill(x-5,y-3,10,6,'#ffcf4d');
      pxFill(x-4,y-2,8,4,'#ff8b2e');
      pxFill(x-2,y-1,4,2,'#fff2b0');
      pxFill(x-6,y-4,12,1,'rgba(255,255,255,0.25)');
    }},
    { name:'SOCK (NO)', base: -15, feed: -18, bad:true, rarity: 0.28, draw:(x,y)=>{
      pxFill(x-5,y-5,10,10,'#13151c');
      pxFill(x-4,y-4,8,8,'#6a7080');
      pxFill(x-2,y-4,4,1,'#8b93a6');
      pxFill(x-1,y+2,2,2,'#4e5462');
      pxFill(x-3,y+1,1,1,'#d28a5e'); // eww speck
    }},
    { name:'GHOST PEPPER', base: -20, feed: -14, bad:true, rarity: 0.26, draw:(x,y)=>{
      pxFill(x-4,y-5,8,11,'#2a0a12');
      pxFill(x-2,y-5,4,10,'#ff2b4f');
      pxFill(x-1,y-4,2,1,'#ff9bb0');
      pxFill(x-1,y-6,2,1,'#21d16c');
      pxFill(x-2,y+3,4,1,'#c0182b');
    }},
  ];
  function pickFoodType(){
    const total = FoodTypes.reduce((s,t)=>s+t.rarity,0);
    let r = Math.random()*total;
    for (const t of FoodTypes){ r -= t.rarity; if (r<=0) return t; }
    return FoodTypes[0];
  }

  // ================= SCRAPS =================
  function spawnScrap(){
    const t = pickFoodType();
    const x = randi(world.left()+18, world.right()-18);
    const y = world.tableY + world.tableTopH + 1;

    const comfort = clamp((60 - state.starving) / 60, 0, 1);
    const diff = clamp(1 + (state.tAlive / 35) + comfort*0.9, 1, 4.2);

    // director also adjusts bad chance slightly by starving state
    const starvingEase = clamp((state.starving - 45) / 55, 0, 1); // high starving -> easier
    const speed = rand(32, 48) + diff*10 - starvingEase*5;

    state.scraps.push({
      x, y,
      vx: rand(-10,10) * (1 + diff*0.10),
      vy: speed,
      wob: rand(0.8, 1.4),
      wT: rand(0, Math.PI*2),
      type: t,
      sparkle: (t.name.includes('GOLD') || t.name.includes('PORTAL')) ? rand(0,1) : 0,
      pulled: 0
    });
  }

  // ================= PARTICLES + FLOATERS =================
  function pop(x,y, count, palette){
    for (let i=0;i<count;i++){
      state.particles.push({
        x, y,
        vx: rand(-45,45),
        vy: rand(-85,-25),
        g: rand(140, 210),
        t: 0,
        life: rand(0.22,0.55),
        c: palette ? palette[randi(0, palette.length-1)] : ['#ffffff','#89d6ff','#ff6aa6','#ffd35a','#56ff96'][randi(0,4)]
      });
    }
  }

  function floatText(x,y,msg,color){
    // keep floaters short so they never overflow on small buffers
    msg = String(msg).toUpperCase();
    if (msg.length > 22) msg = msg.slice(0, 21) + '…';
    state.floaters.push({ x, y, msg, color, t:0, life:0.85, vy:-18 });
  }

  // ================= SLURP =================
  function queueSlurp(){ input.slurpQueued = true; }

  function startSlurp(){
    if (state.slurpCooldown > 0 || state.slurpTime > 0) return;
    state.slurpTime = 0.55;
    state.slurpCooldown = 1.05;
    state.slurpVfx = Math.max(state.slurpVfx, 0.22);
    Audio.sfx('slurp');
    floatText(gizmo.x, gizmo.y - 18, 'SLURP!', '#89d6ff');
  }

  function applySlurp(dt){
    if (state.slurpTime <= 0) return;

    const radius = 58;
    const strength = 980;
    const cx = gizmo.x;
    const cy = gizmo.y + 6;

    for (const s of state.scraps) {
      const badMul = s.type.bad ? 0.55 : 1.0;
      const dx = cx - s.x;
      const dy = cy - s.y;
      const d = Math.max(1, Math.sqrt(dx*dx + dy*dy));
      if (d > radius) continue;

      const t = 1 - (d / radius);
      const accel = strength * (0.35 + 0.65*t) * badMul;

      s.vx += (dx / d) * accel * dt;
      s.vy += (dy / d) * accel * dt;

      s.pulled = 0.30;

      // visible "suction spark"
      state.particles.push({
        x: s.x + rand(-1,1),
        y: s.y + rand(-1,1),
        vx: rand(-12,12),
        vy: rand(-10,10),
        g: 35,
        t: 0,
        life: 0.16,
        c: s.type.bad ? '#ff6aa6' : '#89d6ff'
      });
    }
  }

  function drawSlurpVfx(){
    if (state.slurpVfx <= 0) return;

    const x = gizmo.x|0;
    const y = (gizmo.y + 4)|0;
    const p = state.slurpVfx;
    const r = 10 + Math.round(p * 26);

    // ring
    for (let i=0;i<14;i++){
      const a = (i/14) * Math.PI * 2;
      const px = x + Math.round(Math.cos(a) * r);
      const py = y + Math.round(Math.sin(a) * r);
      pxFill(px, py, 1, 1, 'rgba(137,214,255,0.33)');
    }

    // lines to nearby scraps
    const radius = 58;
    const cx = gizmo.x, cy = gizmo.y + 6;
    let drawn = 0;
    for (const s of state.scraps) {
      const dx = cx - s.x;
      const dy = cy - s.y;
      const d2 = dx*dx + dy*dy;
      if (d2 > radius*radius) continue;
      if (drawn++ > 8) break;

      const steps = 6;
      const col = s.type.bad ? 'rgba(255,106,166,0.26)' : 'rgba(137,214,255,0.42)';
      for (let k=1;k<=steps;k++){
        const tt = k/(steps+1);
        const lx = Math.round(s.x + dx*tt);
        const ly = Math.round(s.y + dy*tt);
        pxFill(lx, ly, 1, 1, col);
      }
    }
  }

  // ================= STARVING DIRECTOR =================
  function starvationTick(dt){
    const comfort = clamp((60 - state.starving) / 60, 0, 1);
    const diff = clamp(1 + (state.tAlive/40) + comfort*0.8, 1, 4.0);
    const passive = (3.3 + diff*1.55) * dt;
    state.starving = clamp(state.starving + passive, 0, 100);

    if (state.starving >= 85) {
      state.dangerPulseT += dt;
      if (state.dangerPulseT >= 0.7) {
        state.dangerPulseT = 0;
        Audio.sfx('danger');
      }
    } else {
      state.dangerPulseT = 0;
    }
  }

  // ================= BACKGROUND (IMPROVED PALETTE + DEPTH) =================
  function drawBackground(){
    // wall gradient
    for (let y=0; y<BH; y++){
      const t = y/BH;
      const r = Math.round(8  + 22*t);
      const g = Math.round(14 + 34*t);
      const b = Math.round(28 + 58*t);
      bctx.fillStyle = `rgb(${r},${g},${b})`;
      bctx.fillRect(0,y,BW,1);
    }

    // wallpaper lines
    for (let x=0; x<BW; x+=10) pxFill(x, 0, 1, world.tableY-8, 'rgba(255,255,255,0.05)');

    // window
    const wx=14, wy=14, ww=62, wh=38;
    pxFill(wx-2, wy-2, ww+4, wh+4, 'rgba(0,0,0,0.28)');
    pxFill(wx, wy, ww, wh, '#0b1430');
    pxFill(wx+2, wy+2, ww-4, wh-4, '#122a6a');
    // stars
    state.scanT += 0.01;
    for (let i=0;i<18;i++){
      const sx = wx+6 + ((i*9 + 11) % (ww-14));
      const sy = wy+6 + ((i*13 + 5) % (wh-14));
      const on = (Math.sin(state.scanT + i*0.9) > 0.25);
      if (on) pxFill(sx, sy, 1, 1, '#eaf6ff');
    }
    // frame + cross
    outlineRect(wx, wy, ww, wh, 'rgba(255,255,255,0.26)');
    pxFill(wx + Math.floor(ww/2), wy, 1, wh, 'rgba(255,255,255,0.18)');
    pxFill(wx, wy + Math.floor(wh/2), ww, 1, 'rgba(255,255,255,0.18)');

    // neon sign
    const sx = BW - 122, sy = 14, sw = 108, sh = 18;
    pxFill(sx, sy, sw, sh, 'rgba(0,0,0,0.28)');
    outlineRect(sx, sy, sw, sh, 'rgba(255,255,255,0.14)');
    drawText('KEEP GIZMO', sx+6, sy+5, '#56ff96', 1, true);
    drawText('ALIVE', sx+6 + 60, sy+5, '#ffd35a', 1, true);

    // table top
    const ty = world.tableY;
    pxFill(0, ty, BW, world.tableTopH, '#6b3b22');
    pxFill(0, ty+2, BW, 2, '#9a6241');               // highlight
    pxFill(0, ty+world.tableTopH, BW, world.tableLipH, '#3a1f12');
    pxFill(0, ty+world.tableTopH+world.tableLipH, BW, 2, 'rgba(0,0,0,0.25)'); // underside shadow

    // table legs w/ highlight
    const legY = ty + world.tableTopH + world.tableLipH;
    const legH = world.floorY() - legY + 6;
    pxFill(26, legY, 12, legH, '#4b2a18');
    pxFill(BW-38, legY, 12, legH, '#4b2a18');
    pxFill(28, legY, 2, legH, 'rgba(255,255,255,0.09)');
    pxFill(BW-36, legY, 2, legH, 'rgba(255,255,255,0.09)');

    // floor tiles
    const fy = world.floorY();
    pxFill(0, fy, BW, BH-fy, '#11172a');
    for (let y=fy; y<BH; y+=10){
      for (let x=0; x<BW; x+=10){
        const odd = ((x/10 + y/10) | 0) % 2;
        pxFill(x,y,10,10, odd ? '#101a33' : '#0d1428');
      }
    }
    pxFill(0, fy, BW, 1, 'rgba(255,255,255,0.18)');

    // subtle CRT scanlines
    for (let y=0; y<BH; y+=2){
      pxFill(0,y,BW,1,'rgba(0,0,0,0.06)');
    }

    // frame vignette
    pxFill(0,0,BW,2,'rgba(0,0,0,0.35)');
    pxFill(0,BH-2,BW,2,'rgba(0,0,0,0.35)');
    pxFill(0,0,2,BH,'rgba(0,0,0,0.35)');
    pxFill(BW-2,0,2,BH,'rgba(0,0,0,0.35)');
  }

  // ================= HUD =================
  function starvingColor(v){
    if (v < 45) return '#56ff96';
    if (v < 75) return '#ffd35a';
    return '#ff2b4f';
  }

  function drawHUD(){
    // top bar background
    pxFill(0,0,BW,18,'rgba(0,0,0,0.38)');
    outlineRect(0,0,BW,18,'rgba(255,255,255,0.10)');

    const st = clamp(state.starving, 0, 100);
    const barW = Math.min(140, Math.floor(BW*0.34));
    const barX = 6, barY = 6;

    // bar frame
    pxFill(barX-1, barY-1, barW+2, 8, 'rgba(0,0,0,0.45)');
    outlineRect(barX-1, barY-1, barW+2, 8, 'rgba(255,255,255,0.18)');
    pxFill(barX, barY, barW, 6, 'rgba(255,255,255,0.05)');
    pxFill(barX, barY, Math.round(barW * (st/100)), 6, starvingColor(st));

    // numeric + score block (right-aligned)
    const rightText = `STARV:${st.toFixed(0)}%  SCORE:${state.score}  STK:${state.streak}`;
    const w = textWidthPx(rightText, 1);
    const rx = BW - 6 - w;
    drawText(rightText, rx, 6, 'rgba(234,246,255,0.92)', 1, true);

    // small tilt indicator on mobile
    if (isCoarse) {
      const ttxt = tilt.enabled ? 'TILT:ON' : 'TILT:OFF';
      drawText(ttxt, barX + barW + 10, 6, tilt.enabled ? '#56ff96' : '#ffd35a', 1, true);
    }
  }

  // ================= OVERLAYS (CENTERED, WRAPPED, NEVER CROPPED) =================
  function drawOverlay(){
    const maxPx = BW - 26;

    const panel = (lines) => {
      // Wrap each input line.
      const wrapped = [];
      for (const l of lines) wrapped.push(...wrapByPixels(l, maxPx, 1));

      const padX = 10, padY = 10;
      const lineH = CHAR_H; // 8
      const w = Math.min(maxPx, Math.max(120, ...wrapped.map(s => textWidthPx(s,1))) + padX*2);
      const h = wrapped.length * lineH + padY*2;

      const x = Math.floor((BW - w)/2);
      const y = Math.floor((BH - h)/2);

      pxFill(x, y, w, h, 'rgba(0,0,0,0.62)');
      outlineRect(x, y, w, h, 'rgba(255,255,255,0.18)');

      let yy = y + padY;
      for (let i=0;i<wrapped.length;i++){
        const s = wrapped[i];
        const xx = Math.floor((BW - textWidthPx(s,1))/2);
        drawText(s, xx, yy, 'rgba(234,246,255,0.92)', 1, true);
        yy += lineH;
      }
    };

    if (state.phase === 'title') {
      panel([
        "GIZMO'S TABLE SCRAPS",
        "TILT TO MOVE. TAP ANYWHERE TO SLURP.",
        "MISS TOO MUCH AND GIZMO EATS A TABLE LEG.",
        "TAP TO START (ALLOW MOTION IF ASKED)."
      ]);

      // accent title
      const title = "GIZMO'S TABLE SCRAPS";
      const tx = Math.floor((BW - textWidthPx(title,1))/2);
      const ty = Math.floor((BH - (4*CHAR_H + 20))/2) + 10;
      drawText(title, tx, ty, '#56ff96', 1, true);
    }

    if (state.phase === 'paused') {
      panel(["PAUSED", "TAP ⏯ OR TAP SCREEN"]);
      const title = "PAUSED";
      const tx = Math.floor((BW - textWidthPx(title,1))/2);
      const ty = Math.floor((BH - (2*CHAR_H + 20))/2) + 10;
      drawText(title, tx, ty, '#ffd35a', 1, true);
    }

    if (state.phase === 'gameover') {
      panel([
        "GAME OVER",
        `SCORE: ${state.score}   BEST: ${state.best}`,
        "TAP TO PLAY AGAIN"
      ]);
      const title = "GAME OVER";
      const tx = Math.floor((BW - textWidthPx(title,1))/2);
      const ty = Math.floor((BH - (3*CHAR_H + 20))/2) + 10;
      drawText(title, tx, ty, '#ff6aa6', 1, true);
    }
  }

  // ================= GAME FLOW =================
  function startGame(){
    state.phase = 'playing';
    state.lastT = now();
    Audio.sfx('start');
    if (tilt.enabled) tilt.zeroSet = false;
  }

  function pauseGame(){
    state.phase = 'paused';
    Audio.sfx('pause');
  }

  function resumeGame(){
    state.phase = 'playing';
    state.lastT = now();
    Audio.sfx('start');
  }

  function restartGame(){
    state.tAlive = 0;
    state.score = 0;
    state.streak = 0;
    state.caught = 0;
    state.missed = 0;
    state.starving = 35;
    state.dangerPulseT = 0;
    state.level = 1;

    state.scraps.length = 0;
    state.particles.length = 0;
    state.floaters.length = 0;

    state.magnetTime = 0;
    state.slowTime = 0;
    state.dashTime = 0;
    state.dashCooldown = 0;
    state.slurpTime = 0;
    state.slurpCooldown = 0;
    state.slurpVfx = 0;

    input.left = input.right = input.dash = false;
    input.slurpQueued = false;

    resetGizmo();
    update.spawnT = 0;

    if (tilt.enabled) tilt.zeroSet = false;
    state.phase = 'playing';
    state.lastT = now();
    Audio.sfx('start');
  }

  function gameOver(){
    state.best = Math.max(state.best, state.score);
    state.phase = 'gameover';
    Audio.sfx('gameover');
  }

  // ================= UPDATE =================
  function update(dt){
    state.tAlive += dt;

    // timers
    if (state.magnetTime > 0) state.magnetTime = Math.max(0, state.magnetTime - dt);
    if (state.slowTime > 0) state.slowTime = Math.max(0, state.slowTime - dt);
    if (state.dashTime > 0) state.dashTime = Math.max(0, state.dashTime - dt);
    if (state.dashCooldown > 0) state.dashCooldown = Math.max(0, state.dashCooldown - dt);
    if (state.slurpTime > 0) state.slurpTime = Math.max(0, state.slurpTime - dt);
    if (state.slurpCooldown > 0) state.slurpCooldown = Math.max(0, state.slurpCooldown - dt);
    if (state.slurpVfx > 0) state.slurpVfx = Math.max(0, state.slurpVfx - dt);

    // hunger
    starvationTick(dt);
    if (state.starving >= 100) { gameOver(); return; }

    // slow time
    const slowFactor = (state.slowTime > 0) ? 0.62 : 1.0;
    dt *= slowFactor;

    // dash (button/key)
    if (input.dash && state.dashCooldown <= 0 && state.dashTime <= 0) {
      state.dashTime = 0.25;
      state.dashCooldown = 1.25;
      Audio.sfx('dash');
    }

    // slurp (tap anywhere or key)
    if (input.slurpQueued) {
      startSlurp();
      input.slurpQueued = false;
    }

    // movement (tilt + buttons)
    const dashMul = (state.dashTime > 0) ? 1.75 : 1.0;
    gizmo.bob += dt * (Math.abs(gizmo.vx) > 1 ? 8 : 3);
    if (Math.abs(gizmo.vx) > 8) gizmo.step += dt * 12;

    let dir = 0;
    if (isCoarse && tilt.enabled) {
      const dead = 2.0;
      const v = (Math.abs(tilt.smooth) < dead) ? 0 : tilt.smooth;
      dir += clamp(v / 16, -1.2, 1.2);
    }
    dir += (input.left ? -1 : 0) + (input.right ? 1 : 0);
    dir = clamp(dir, -1.6, 1.6);

    gizmo.vx = dir * gizmo.speed * dashMul;
    gizmo.x += gizmo.vx * dt;
    gizmo.x = clamp(gizmo.x, world.left()+12, world.right()-12);
    gizmo.mouth = Math.max(0, gizmo.mouth - dt*4);

    // spawn director
    state.level = 1 + Math.floor(state.tAlive / 18);
    const starvingEase = clamp((state.starving - 40) / 60, 0, 1);
    const comfort = clamp((60 - state.starving) / 60, 0, 1);
    const diff = clamp(1 + (state.tAlive/35) + comfort*0.9, 1, 4.2);

    const spawnEvery = clamp(0.70 - diff*0.12 + starvingEase*0.10, 0.26, 0.75);
    update.spawnT = (update.spawnT ?? 0) + dt;
    while (update.spawnT >= spawnEvery) {
      update.spawnT -= spawnEvery;
      spawnScrap();
      if (Math.random() < (0.03 + diff*0.02) && starvingEase < 0.85) spawnScrap();
    }

    // slurp forces
    applySlurp(dt);

    // scraps update + collision
    const fy = world.floorY();
    const catchW = 30, catchH = 20; // slightly more forgiving
    const catchX = gizmo.x - catchW/2;
    const catchY = gizmo.y - 1;

    for (let i=state.scraps.length-1; i>=0; i--){
      const s = state.scraps[i];

      // magnet assist for good items
      const baseMag = 0.08;
      const powerMag = (state.magnetTime > 0) ? 0.42 : 0;
      const magStrength = baseMag + powerMag;

      if (!s.type.bad) {
        const pull = clamp((gizmo.x - s.x) * 0.8, -60, 60);
        s.vx += pull * magStrength * dt;
      }

      s.wT += dt * s.wob;
      s.x += s.vx * dt + Math.sin(s.wT) * 4 * dt;
      s.y += s.vy * dt;

      if (s.x < world.left()+8){ s.x = world.left()+8; s.vx *= -0.35; }
      if (s.x > world.right()-8){ s.x = world.right()-8; s.vx *= -0.35; }

      if (s.sparkle) s.sparkle = (s.sparkle + dt*3) % 1;
      if (s.pulled > 0) s.pulled = Math.max(0, s.pulled - dt);

      const sx = s.x|0, sy = s.y|0;

      // catch
      if (sx >= catchX && sx <= catchX+catchW && sy >= catchY && sy <= catchY+catchH) {
        state.scraps.splice(i,1);
        gizmo.mouth = 1;
        state.caught++;

        const streakTier = Math.min(4, Math.floor(state.streak / 6));

        if (s.type.bad) {
          state.streak = 0;
          state.score = Math.max(0, state.score + s.type.base);
          state.starving = clamp(state.starving + (10 + Math.abs(s.type.feed)), 0, 100);

          Audio.sfx('bad');
          pop(sx, sy, 18, ['#ff2b4f','#ff6aa6','#ffd35a']);
          floatText(sx, sy-10, `NOPE ${s.type.name}`, '#ff6aa6');
        } else {
          state.streak += 1;

          const comboBonus = streakTier * 4;
          const pts = Math.max(1, s.type.base + comboBonus);
          state.score += pts;

          const feedBonus = 1.5 * streakTier;
          state.starving = clamp(state.starving - (s.type.feed + feedBonus), 0, 100);

          if (s.type.onCatch) s.type.onCatch();

          if (pts >= 30 || streakTier >= 3) Audio.sfx('bonus');
          else Audio.sfx('catch');

          pop(sx, sy, 12 + Math.floor(pts/9));
          floatText(sx, sy-10, `+${pts} ${s.type.name}`, '#eaf6ff');
        }

        if (state.starving >= 100) { gameOver(); return; }
        continue;
      }

      // miss
      if (s.y > fy + 10) {
        state.scraps.splice(i,1);
        state.missed++;
        if (state.streak > 0) state.streak = 0;

        const dangerEase = clamp((state.starving - 70)/30, 0, 1);
        const missBase = 6.8 + clamp(state.tAlive/55, 0, 3.0);
        const missBonus = (1 - dangerEase) * 2.5;
        state.starving = clamp(state.starving + missBase + missBonus, 0, 100);

        state.score = Math.max(0, state.score - 1);

        Audio.sfx('miss');
        pop(sx, fy, 10, ['#89d6ff','#eaf6ff','#56ff96']);

        if (state.starving >= 100) { gameOver(); return; }
      }
    }

    // particles
    for (let i=state.particles.length-1; i>=0; i--){
      const p = state.particles[i];
      p.t += dt;
      p.vy += p.g * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.t >= p.life) state.particles.splice(i,1);
    }

    // floaters
    for (let i=state.floaters.length-1; i>=0; i--){
      const f = state.floaters[i];
      f.t += dt;
      f.y += f.vy * dt;
      if (f.t >= f.life) state.floaters.splice(i,1);
    }
  }

  // ================= DRAW =================
  function drawScrap(s){
    const x = s.x|0, y = s.y|0;

    // tiny shadow
    pxFill(x-3, y+6, 6, 1, 'rgba(0,0,0,0.22)');

    s.type.draw(x,y);

    if (s.sparkle) {
      const on = (s.sparkle < 0.33) || (s.sparkle > 0.66);
      if (on) {
        pxFill(x-7,y-7,1,1,'#fff2b0');
        pxFill(x+6,y-2,1,1,'#fff2b0');
        pxFill(x-2,y+7,1,1,'#fff2b0');
      }
    }
    if (s.pulled > 0) {
      pxFill(x-6, y-6, 1, 1, 'rgba(137,214,255,0.85)');
      pxFill(x+6, y-4, 1, 1, 'rgba(86,255,150,0.85)');
    }
  }

  function drawParticles(){
    for (const p of state.particles){
      const a = 1 - (p.t / p.life);
      bctx.globalAlpha = Math.max(0, Math.min(1, a));
      pxFill(p.x|0, p.y|0, 2, 2, p.c);
    }
    bctx.globalAlpha = 1;
  }

  function drawFloaters(){
    for (const f of state.floaters){
      const a = 1 - (f.t / f.life);
      bctx.globalAlpha = Math.max(0, Math.min(1, a));
      const w = textWidthPx(f.msg, 1);
      drawText(f.msg, (f.x|0) - Math.floor(w/2), f.y|0, f.color, 1, true);
    }
    bctx.globalAlpha = 1;
  }

  function render(){
    // clear
    bctx.clearRect(0,0,BW,BH);

    drawBackground();

    // game objects
    for (const s of state.scraps) drawScrap(s);
    drawParticles();
    drawSlurpVfx();
    drawGizmo();
    drawFloaters();
    drawHUD();
    drawOverlay();

    // blit to screen
    sctx.imageSmoothingEnabled = false;
    sctx.clearRect(0,0,window.innerWidth, window.innerHeight);
    sctx.drawImage(buf, 0, 0, BW, BH, ox, oy, BW*scale, BH*scale);
  }

  // ================= INPUT WIRING =================
  // Tap anywhere in-game = SLURP. Tap on title/gameover = start/restart. Tap when paused = resume.
  async function handleCanvasTap(e){
    e.preventDefault();
    unlockAudioOnce();
    await requestTiltPermissionOnce();

    if (state.phase === 'title') {
      resetGizmo();
      startGame();
      return;
    }
    if (state.phase === 'gameover') {
      restartGame();
      return;
    }
    if (state.phase === 'paused') {
      resumeGame();
      return;
    }
    // playing:
    queueSlurp();
  }

  // Prefer pointer events; add touchstart fallback.
  screen.addEventListener('pointerdown', handleCanvasTap, { passive:false });
  screen.addEventListener('touchstart', handleCanvasTap, { passive:false });

  // Keyboard (desktop)
   document.addEventListener('keydown', (e) => {
    unlockAudioOnce();

    const isSpace =
      e.code === 'Space' ||
      e.code === 'Spacebar' ||       // older Safari / some keyboards
      e.key === ' ' ||               // most reliable
      e.key === 'Spacebar';

    const owned = new Set([
      'ArrowLeft','ArrowRight','ArrowUp',
      'KeyA','KeyD','KeyX',
      'ShiftLeft','ShiftRight',
      'KeyR','KeyM','KeyB'
    ]);

    if (owned.has(e.code) || isSpace) e.preventDefault();

    // Space behavior: start / pause / resume / restart
    if (isSpace) {
      if (state.phase === 'title') startGame();
      else if (state.phase === 'paused') resumeGame();
      else if (state.phase === 'playing') pauseGame();
      else restartGame(); // gameover (or anything unexpected) -> restart
      return;
    }

    if (e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') input.right = true;
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') input.dash = true;

    if (e.code === 'KeyX' || e.code === 'ArrowUp') queueSlurp();

    if (e.code === 'KeyR') restartGame();
    if (e.code === 'KeyM') Audio.setMute(!Audio.muted);
    if (e.code === 'KeyB') { Audio.musicOn = !Audio.musicOn; if (!Audio.musicOn) Audio.stopMusic(); }
  }, { capture:true, passive:false });

  document.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') input.right = false;
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') input.dash = false;
  }, { capture:true, passive:true });

  // Mobile buttons
  function bindHoldButton(el, onDown, onUp) {
    const down = async (ev) => { ev.preventDefault(); ev.stopPropagation(); unlockAudioOnce(); await requestTiltPermissionOnce(); onDown(); };
    const up   = (ev) => { ev.preventDefault(); ev.stopPropagation(); onUp(); };
    el.addEventListener('pointerdown', down, { passive:false });
    el.addEventListener('pointerup', up, { passive:false });
    el.addEventListener('pointercancel', up, { passive:false });
    el.addEventListener('pointerleave', up, { passive:false });
  }

  document.querySelectorAll('[data-act]').forEach(btn => {
    const act = btn.getAttribute('data-act');
    if (act === 'left')  bindHoldButton(btn, () => { input.left = true; }, () => { input.left = false; });
    if (act === 'right') bindHoldButton(btn, () => { input.right = true; }, () => { input.right = false; });
    if (act === 'dash')  bindHoldButton(btn, () => { input.dash = true; }, () => { input.dash = false; });
    if (act === 'cal') {
      btn.addEventListener('pointerdown', async (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        unlockAudioOnce();
        await requestTiltPermissionOnce();
        calibrateTilt();
        floatText(gizmo.x, gizmo.y - 18, 'CALIBRATED', '#56ff96');
      }, { passive:false });
    }
    if (act === 'pause') {
      btn.addEventListener('pointerdown', async (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        unlockAudioOnce();
        await requestTiltPermissionOnce();

        if (state.phase === 'title') startGame();
        else if (state.phase === 'paused') resumeGame();
        else if (state.phase === 'playing') pauseGame();
        else if (state.phase === 'gameover') restartGame();
      }, { passive:false });
    }
  });

  // ================= MAIN LOOP =================
  function loop(){
    requestAnimationFrame(loop);

    const t = now();
    let dt = (t - state.lastT)/1000;
    state.lastT = t;
    dt = Math.min(dt, 0.05);

    const active = (state.phase === 'playing');

    if (active) update(dt);
    render();

    if (Audio.ctx) Audio.tickMusic(active);
  }
  loop();
})();
</script>
</body>
</html>
