<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- iOS Safari: prevent zoom + allow safe-area layout -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Gizmo’s Table Scraps (16-bit + Tilt + Tap-Slurp)</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      height: 100%;
      margin: 0;
      background:#05060a;
      overflow:hidden;
      overscroll-behavior: none;
      touch-action: none; /* helps on modern browsers */
      -webkit-text-size-adjust: 100%;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display:block;
      width:100vw;
      height:100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      touch-action: none;
    }

    /* Mobile controls (kept as backup even with tilt) */
    #mobileControls {
      position: fixed;
      left: 0; right: 0;
      bottom: calc(10px + env(safe-area-inset-bottom));
      display: none;
      justify-content: space-between;
      gap: 10px;
      padding: 0 12px;
      pointer-events: none;
    }
    .pad, .actions { display:flex; gap:10px; pointer-events:auto; }
    .btn {
      -webkit-tap-highlight-color: transparent;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.9);
      font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-weight: 800;
      border-radius: 14px;
      padding: 14px 14px;
      min-width: 64px;
      text-align: center;
      touch-action: none;
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
    }
    .btn:active { transform: translateY(1px); }
    .btn.small { min-width: 56px; padding: 12px 12px; }
    .btn.wide { min-width: 90px; }

    @media (pointer: coarse), (max-width: 820px) {
      #mobileControls { display: flex; }
    }
  </style>
</head>
<body>
  <canvas id="screen"></canvas>

  <div id="mobileControls" aria-label="Mobile controls">
    <div class="pad">
      <div class="btn" data-act="left">◀</div>
      <div class="btn" data-act="right">▶</div>
    </div>
    <div class="actions">
      <div class="btn wide" data-act="dash">DASH</div>
      <div class="btn small" data-act="pause">⏯</div>
    </div>
  </div>

<script>
(() => {
  // ======== iOS SAFARI: HARD STOP ON DOUBLE-TAP/PINCH ZOOM ========
  // (iOS ignores parts of touch-action; these handlers are the reliable approach.)
  document.addEventListener('dblclick', (e) => e.preventDefault(), { passive:false });
  ['gesturestart','gesturechange','gestureend'].forEach(evt =>
    document.addEventListener(evt, (e) => e.preventDefault(), { passive:false })
  );
  let __lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const t = Date.now();
    if (t - __lastTouchEnd <= 300) e.preventDefault();
    __lastTouchEnd = t;
  }, { passive:false });

  // ======== PIXEL / RENDER SETUP ========
  const screen = document.getElementById('screen');
  const sctx = screen.getContext('2d');

  const buf = document.createElement('canvas');
  const bctx = buf.getContext('2d');

  const isCoarse = window.matchMedia("(pointer: coarse)").matches;

  const BASE_H = 180;
  let BW = 320, BH = BASE_H;
  let scale = 3, ox = 0, oy = 0;

  function resize() {
    const W = window.innerWidth, H = window.innerHeight;
    screen.width = Math.floor(W * devicePixelRatio);
    screen.height = Math.floor(H * devicePixelRatio);
    sctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

    const aspect = W / H;
    BH = BASE_H;
    const maxW = isCoarse ? 460 : 560; // bigger sprites on phone
    BW = Math.max(256, Math.min(maxW, Math.round(BH * aspect)));
    buf.width = BW;
    buf.height = BH;

    scale = Math.max(2, Math.floor(Math.min(W / BW, H / BH)));
    const rw = BW * scale, rh = BH * scale;
    ox = Math.floor((W - rw) / 2);
    oy = Math.floor((H - rh) / 2);

    sctx.imageSmoothingEnabled = false;
    bctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', resize);
  resize();

  // ======== UTIL ========
  const rand  = (a,b) => a + Math.random()*(b-a);
  const randi = (a,b) => Math.floor(rand(a,b+1));
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const now   = () => performance.now();

  function pxFill(x,y,w,h,c){ bctx.fillStyle=c; bctx.fillRect(x|0,y|0,w|0,h|0); }
  function setFont8(){ bctx.font = '8px ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace'; }
  function textW(msg){ setFont8(); return Math.ceil(bctx.measureText(msg).width); }
  function pxText(txt,x,y,c){
    bctx.fillStyle = c;
    setFont8();
    bctx.textBaseline='top';
    bctx.fillText(txt, x|0, y|0);
  }
  function outlineRect(x,y,w,h,c){
    bctx.strokeStyle=c;
    bctx.lineWidth=1;
    bctx.strokeRect((x|0)+.5,(y|0)+.5,w|0,h|0);
  }

  function wrapText(msg, maxPx){
    setFont8();
    const words = msg.split(/\s+/);
    const lines = [];
    let line = '';
    for (const w of words) {
      const cand = line ? (line + ' ' + w) : w;
      if (textW(cand) <= maxPx) { line = cand; continue; }
      if (line) lines.push(line);
      // if a single word is too long, hard-split it
      if (textW(w) > maxPx) {
        let chunk = '';
        for (const ch of w) {
          const cc = chunk + ch;
          if (textW(cc) <= maxPx) chunk = cc;
          else { lines.push(chunk); chunk = ch; }
        }
        line = chunk;
      } else {
        line = w;
      }
    }
    if (line) lines.push(line);
    return lines;
  }

  function drawCenteredPanel(lines, yCenter, bg='rgba(0,0,0,0.58)'){
    const maxPx = BW - 24;
    // wrap all lines
    const wrapped = [];
    for (const l of lines) wrapped.push(...wrapText(l, maxPx));
    const padX = 8, padY = 8;
    const lineH = 10;
    const w = Math.min(maxPx, Math.max(120, ...wrapped.map(textW)) + padX*2);
    const h = wrapped.length * lineH + padY*2;
    const x = Math.floor((BW - w) / 2);
    const y = Math.floor(yCenter - h/2);

    pxFill(x, y, w, h, bg);
    outlineRect(x, y, w, h, 'rgba(255,255,255,0.18)');

    let yy = y + padY;
    for (let i=0;i<wrapped.length;i++){
      const line = wrapped[i];
      const xx = Math.floor((BW - textW(line)) / 2);
      // color first/second lines differently if desired by caller (caller can embed tags, but keep simple)
      pxText(line, xx, yy, 'rgba(234,246,255,0.92)');
      yy += lineH;
    }
    return { x, y, w, h, wrapped };
  }

  // ======== AUDIO (WEB AUDIO, NO FILES) ========
  const Audio = {
    ctx: null,
    master: null,
    gain: 0.45,
    muted: false,
    musicOn: true,
    music: { nextT: 0, step: 0, isActive: false },

    ensure() {
      if (this.ctx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return;
      this.ctx = new Ctx();
      this.master = this.ctx.createGain();
      this.master.gain.value = this.muted ? 0 : this.gain;
      this.master.connect(this.ctx.destination);
    },
    resume() {
      if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    },
    setMute(v) { this.muted = v; if (this.master) this.master.gain.value = v ? 0 : this.gain; },
    setGain(g) { this.gain = clamp(g,0,1); if (this.master) this.master.gain.value = this.muted ? 0 : this.gain; },

    beep({freq=440, dur=0.08, type='square', vol=0.7, attack=0.005, decay=0.06, slide=0, detune=0} = {}) {
      if (!this.ctx || !this.master) return;
      const t0 = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;
      o.detune.value = detune;

      const f0 = Math.max(40, freq);
      o.frequency.setValueAtTime(f0, t0);
      if (slide !== 0) o.frequency.exponentialRampToValueAtTime(Math.max(40, f0 + slide), t0 + dur);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.linearRampToValueAtTime(vol, t0 + attack);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + attack + decay);

      o.connect(g); g.connect(this.master);
      o.start(t0); o.stop(t0 + dur + 0.02);
    },
    chord(freqs, dur=0.12, type='square', vol=0.16) {
      for (let i=0;i<freqs.length;i++){
        this.beep({freq: freqs[i], dur, type, vol, attack:0.003, decay:dur*0.85, detune:(i-1)*3});
      }
    },
    sfx(name) {
      if (!this.ctx) return;
      switch (name) {
        case 'start':    this.beep({freq:660, dur:0.07, type:'square', vol:0.55, slide:120}); break;
        case 'pause':    this.beep({freq:330, dur:0.07, type:'square', vol:0.45, slide:-60}); break;
        case 'catch':    this.beep({freq:880, dur:0.06, type:'square', vol:0.50, slide:80}); break;
        case 'bonus':    this.chord([523.25, 659.25, 783.99], 0.10, 'square', 0.14); break;
        case 'power':    this.beep({freq:440, dur:0.10, type:'triangle', vol:0.50, slide:440}); break;
        case 'bad':      this.chord([220, 233.08, 246.94], 0.10, 'sawtooth', 0.10); break;
        case 'miss':     this.beep({freq:210, dur:0.07, type:'triangle', vol:0.30, slide:-90}); break;
        case 'dash':     this.beep({freq:520, dur:0.06, type:'square', vol:0.35, slide:260}); break;
        case 'slurp':    this.beep({freq:250, dur:0.14, type:'triangle', vol:0.45, slide:700}); break;
        case 'danger':   this.beep({freq:180, dur:0.12, type:'sawtooth', vol:0.22, slide:-30}); break;
        case 'gameover':
          this.beep({freq:392, dur:0.10, type:'triangle', vol:0.40, slide:-120});
          setTimeout(()=>this.beep({freq:330, dur:0.10, type:'triangle', vol:0.36, slide:-120}), 90);
          setTimeout(()=>this.beep({freq:262, dur:0.16, type:'triangle', vol:0.34, slide:-80}), 180);
          break;
      }
    },

    startMusic() { if (!this.ctx) return; this.music.isActive = true; this.music.nextT = Math.max(this.music.nextT, this.ctx.currentTime + 0.03); },
    stopMusic()  { this.music.isActive = false; },

    tickMusic(isGameplayActive) {
      if (!this.ctx || !this.master) return;
      if (!this.musicOn || !isGameplayActive) return;
      if (!this.music.isActive) this.startMusic();

      const stepDur = 0.125;
      const lookAhead = 0.20;

      const pattern = [
        440, 523.25, 659.25, 523.25,
        392, 493.88, 587.33, 493.88,
        349.23, 440, 523.25, 440,
        392, 440, 493.88, 440
      ];
      const bass = [
        110, 0, 0, 0,
        98,  0, 0, 0,
        87.31,0,0,0,
        98,  0, 0, 0
      ];

      while (this.music.nextT < this.ctx.currentTime + lookAhead) {
        const i = this.music.step % pattern.length;
        const f = pattern[i];
        const b = bass[i];

        if (f) {
          const t0 = this.music.nextT;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = 'square';
          o.frequency.setValueAtTime(f, t0);
          g.gain.setValueAtTime(0.0001, t0);
          g.gain.linearRampToValueAtTime(0.11, t0 + 0.004);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + stepDur * 0.92);
          o.connect(g); g.connect(this.master);
          o.start(t0); o.stop(t0 + stepDur);
        }
        if (b) {
          const t0 = this.music.nextT;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = 'triangle';
          o.frequency.setValueAtTime(b, t0);
          g.gain.setValueAtTime(0.0001, t0);
          g.gain.linearRampToValueAtTime(0.07, t0 + 0.004);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + stepDur * 0.95);
          o.connect(g); g.connect(this.master);
          o.start(t0); o.stop(t0 + stepDur);
        }

        this.music.step++;
        this.music.nextT += stepDur;
      }
    }
  };

  function unlockAudioOnce(){ Audio.ensure(); Audio.resume(); }

  // ======== WORLD ========
  const world = {
    tableY: 44,
    tableTopH: 10,
    tableLipH: 5,
    floorY: () => BH - 22,
    left: () => 14,
    right: () => BW - 14,
  };

  // ======== INPUT ========
  const input = {
    left:false, right:false, dash:false,
    mode:'keys', // 'keys' | 'pointer' (pointer move only on non-mobile)
    targetX:null,
    lastKeyMs: 0,
    slurpPulse: false, // one-shot (tap)
  };

  function setKeysMode(){ input.mode='keys'; input.lastKeyMs=now(); input.targetX=null; }

  // Pointer-move (desktop only)
  function screenToWorldX(clientX){
    const x = clientX - ox;
    return clamp(Math.round(x / scale), 0, BW);
  }
  function maybeSetPointerMode(x){
    const t = now();
    if ((t - input.lastKeyMs) < 220) return;
    input.mode='pointer';
    input.targetX = x;
  }
  if (!isCoarse) {
    window.addEventListener('mousemove', (e) => {
      const x = screenToWorldX(e.clientX);
      if (input.targetX === null || Math.abs(x - input.targetX) >= 2) maybeSetPointerMode(x);
    });
  }

  // Keyboard (still useful on desktop)
  document.addEventListener('keydown', (e) => {
    unlockAudioOnce();
    const code = e.code;
    const owned = new Set([
      'ArrowLeft','ArrowRight','ArrowUp','Space','KeyA','KeyD','KeyX','ShiftLeft','ShiftRight',
      'KeyR','KeyM','KeyB','Minus','Equal','NumpadAdd','NumpadSubtract'
    ]);
    if (owned.has(code)) e.preventDefault();

    if (code === 'ArrowLeft' || code === 'KeyA') { input.left = true; setKeysMode(); }
    if (code === 'ArrowRight' || code === 'KeyD') { input.right = true; setKeysMode(); }
    if (code === 'ShiftLeft' || code === 'ShiftRight') input.dash = true;

    if (code === 'KeyX' || code === 'ArrowUp') input.slurpPulse = true;

    if (code === 'Space') {
      if (!state.running) start();
      else togglePause();
    }
    if (code === 'KeyR') restart();
    if (code === 'KeyM') Audio.setMute(!Audio.muted);
    if (code === 'KeyB') { Audio.musicOn = !Audio.musicOn; if (!Audio.musicOn) Audio.stopMusic(); }
    if (code === 'Minus' || code === 'NumpadSubtract') Audio.setGain(Audio.gain - 0.08);
    if (code === 'Equal' || code === 'NumpadAdd') Audio.setGain(Audio.gain + 0.08);
  }, { capture:true, passive:false });

  document.addEventListener('keyup', (e) => {
    const code = e.code;
    if (code === 'ArrowLeft' || code === 'KeyA') input.left = false;
    if (code === 'ArrowRight' || code === 'KeyD') input.right = false;
    if (code === 'ShiftLeft' || code === 'ShiftRight') input.dash = false;
  }, { capture:true, passive:true });

  // ======== TILT CONTROLS (iOS permission) ========
  const tilt = {
    supported: !!window.DeviceOrientationEvent,
    enabled: false,
    requested: false,
    zeroSet: false,
    zero: 0,
    raw: 0,
    smooth: 0
  };

  function orientationAngle(){
    if (screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
    if (typeof window.orientation === 'number') return window.orientation;
    return 0;
  }

  function onDeviceOrientation(e){
    if (e.gamma == null && e.beta == null) return;

    // Map "left-right tilt" consistently across orientations.
    const ang = orientationAngle();
    let lr;
    // portrait: use gamma
    if (ang === 0) lr = e.gamma;
    // upside-down portrait
    else if (ang === 180) lr = -e.gamma;
    // landscape right (home button / bar on left): use -beta
    else if (ang === 90) lr = -e.beta;
    // landscape left: use beta
    else if (ang === -90 || ang === 270) lr = e.beta;
    else lr = e.gamma;

    if (!tilt.zeroSet) { tilt.zero = lr || 0; tilt.zeroSet = true; }
    tilt.raw = (lr || 0) - tilt.zero;
    tilt.smooth = tilt.smooth * 0.86 + tilt.raw * 0.14;
  }

  function enableTilt(){
    if (tilt.enabled) return;
    tilt.enabled = true;
    tilt.zeroSet = false;
    tilt.smooth = 0;
    window.addEventListener('deviceorientation', onDeviceOrientation, true);
  }

  async function requestTiltPermissionOnce(){
    if (!isCoarse) return; // only bother on mobile
    if (!tilt.supported || tilt.requested) return;
    tilt.requested = true;

    try {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res === 'granted') enableTilt();
      } else {
        // older iOS
        enableTilt();
      }
    } catch (_) {
      // permission denied or not available
    }
  }

  // ======== GAME STATE ========
  const state = {
    running: false,
    paused: true,
    lastT: now(),
    tAlive: 0,

    score: 0,
    best: 0,
    streak: 0,
    caught: 0,
    missed: 0,

    starving: 35, // 0..100
    dangerPulseT: 0,
    level: 1,

    scraps: [],
    particles: [],
    floaters: [],

    magnetTime: 0,
    slowTime: 0,

    dashTime: 0,
    dashCooldown: 0,

    slurpTime: 0,
    slurpCooldown: 0,
    slurpVfx: 0,

    twinkleT: 0
  };

  // ======== GIZMO ========
  const gizmo = { x: 160, y: 0, vx: 0, speed: 220, mouth: 0, bob: 0 };

  function resetGizmo(){
    gizmo.x = Math.floor(BW/2);
    gizmo.y = world.floorY() - 14;
    gizmo.vx = 0;
    gizmo.mouth = 0;
    gizmo.bob = 0;
  }
  resetGizmo();

  function drawGizmo(){
    const x = gizmo.x|0, y = gizmo.y|0;
    const bob = Math.round(Math.sin(gizmo.bob)*1);

    pxFill(x-11, world.floorY()+4, 22, 3, 'rgba(0,0,0,0.35)');

    pxFill(x-12, y+6+bob, 24, 9, '#0b0e16');
    pxFill(x-10, y+5+bob, 20, 2, '#0f1420');
    pxFill(x-10, y+14+bob, 4, 2, '#070a10');
    pxFill(x-2,  y+14+bob, 4, 2, '#070a10');
    pxFill(x+6,  y+14+bob, 4, 2, '#070a10');

    pxFill(x-10, y-1+bob, 20, 12, '#0a0d15');
    pxFill(x-8,  y+bob,   16, 2,  '#10182a');
    pxFill(x-12, y-2+bob, 5, 6, '#070a10');
    pxFill(x+7,  y-2+bob, 5, 6, '#070a10');

    pxFill(x-5, y+5+bob, 10, 6, '#070911');
    pxFill(x-6, y+2+bob, 3, 3, '#eaf6ff');
    pxFill(x+3, y+2+bob, 3, 3, '#eaf6ff');
    pxFill(x-5, y+3+bob, 1, 1, '#1b4a7a');
    pxFill(x+4, y+3+bob, 1, 1, '#1b4a7a');

    pxFill(x-2, y+6+bob, 4, 2, '#010103');

    const m = gizmo.mouth;
    pxFill(x-3, y+8+bob, 6, 1, 'rgba(255,255,255,0.18)');
    if (m > 0.02) {
      pxFill(x-2, y+9+bob, 4, 1, '#ff6aa6');
      pxFill(x-3, y+10+bob, 6, 1, '#05060a');
    }

    pxFill(x-10, y+11+bob, 20, 2, '#c0182b');
    pxFill(x-2,  y+11+bob, 4, 2, '#ffcf4d');
  }

  // ======== FUNNY FOOD TYPES ========
  const FoodTypes = [
    { name:'Couch Fry (Vintage)', base: 14, feed: 12, rarity: 1.0, draw:(x,y)=>{ pxFill(x-3,y-3,6,6,'#5a3a1a'); pxFill(x-2,y-4,1,7,'#ffd35a'); pxFill(x,y-4,1,7,'#ffd35a'); pxFill(x+2,y-4,1,7,'#ffd35a'); }},
    { name:'Nacho Shard of Power', base: 11, feed: 9,  rarity: 1.0, draw:(x,y)=>{ pxFill(x-4,y-2,8,4,'#ffcf4d'); pxFill(x-2,y-3,4,1,'#ffdca0'); pxFill(x-1,y,2,1,'#e58f2a'); }},
    { name:'Half-Eaten Taco (Hero)', base: 18, feed: 16, rarity: 0.85, draw:(x,y)=>{ pxFill(x-5,y-2,10,4,'#c77a22'); pxFill(x-4,y-1,8,2,'#2bdc74'); pxFill(x-2,y-1,4,1,'#ff6aa6'); }},
    { name:'Mysterious Meatball', base: 16, feed: 13, rarity: 0.9, draw:(x,y)=>{ pxFill(x-4,y-4,8,8,'#a14f2a'); pxFill(x-2,y-2,1,1,'#d28a5e'); pxFill(x+1,y,1,1,'#d28a5e'); }},
    { name:'Floor Grape (Probably Fine)', base: 9, feed: 7, rarity: 1.0, draw:(x,y)=>{ pxFill(x-3,y-3,6,6,'#7a3bd1'); pxFill(x-2,y-2,2,2,'#c9a2ff'); pxFill(x+1,y-1,1,1,'#c9a2ff'); }},
    { name:'Wet Lettuce (Sad)', base: 6, feed: 9, rarity: 0.95, draw:(x,y)=>{ pxFill(x-4,y-3,8,6,'#1fbf5f'); pxFill(x-3,y-2,2,2,'#56ff96'); pxFill(x+1,y+1,2,1,'#128a44'); }},
    { name:'Single Onion Ring Portal', base: 22, feed: 10, rarity: 0.5, onCatch:()=>{ state.magnetTime = 5.0; Audio.sfx('power'); }, draw:(x,y)=>{ pxFill(x-5,y-5,10,10,'#d7a52b'); pxFill(x-3,y-3,6,6,'#05060a'); pxFill(x-4,y-4,8,1,'#fff2b0'); }},
    { name:'Ice Cube of Time', base: 10, feed: 8, rarity: 0.38, onCatch:()=>{ state.slowTime = 5.0; Audio.sfx('power'); }, draw:(x,y)=>{ pxFill(x-4,y-4,8,8,'#89d6ff'); pxFill(x-3,y-3,6,6,'#c9f0ff'); pxFill(x-2,y-2,4,4,'#89d6ff'); }},
    { name:'Steak of Destiny (GOLD)', base: 55, feed: 12, rarity: 0.16, onCatch:()=>{ state.magnetTime = 7.0; Audio.sfx('power'); }, draw:(x,y)=>{ pxFill(x-5,y-3,10,6,'#ffcf4d'); pxFill(x-4,y-2,8,4,'#ff8b2e'); pxFill(x-2,y-1,4,2,'#fff2b0'); pxFill(x-6,y-4,12,1,'rgba(255,255,255,0.25)'); }},
    { name:'Sock (Not Food)', base: -15, feed: -18, bad:true, rarity: 0.28, draw:(x,y)=>{ pxFill(x-4,y-4,8,8,'#6a7080'); pxFill(x-2,y-4,4,1,'#8b93a6'); pxFill(x-1,y+2,2,2,'#4e5462'); }},
    { name:'Ghost Pepper Regret', base: -20, feed: -14, bad:true, rarity: 0.26, draw:(x,y)=>{ pxFill(x-2,y-4,4,8,'#ff2b4f'); pxFill(x-1,y-3,2,1,'#ff9bb0'); pxFill(x-1,y-5,2,1,'#21d16c'); }},
  ];
  function pickFoodType(){
    const total = FoodTypes.reduce((s,t)=>s+t.rarity,0);
    let r = Math.random()*total;
    for (const t of FoodTypes){ r -= t.rarity; if (r<=0) return t; }
    return FoodTypes[0];
  }

  // ======== SCRAPS ========
  function spawnScrap(){
    const t = pickFoodType();
    const x = randi(world.left()+18, world.right()-18);
    const y = world.tableY + 10;

    const comfort = clamp((60 - state.starving) / 60, 0, 1);
    const diff = clamp(1 + (state.tAlive / 35) + comfort*0.9, 1, 4.2);

    state.scraps.push({
      x, y,
      vx: rand(-12,12) * (1 + diff*0.10),
      vy: rand(34, 50) + diff*10,
      wob: rand(0.8, 1.4),
      wT: rand(0, Math.PI*2),
      type: t,
      sparkle: (t.name.includes('GOLD') || t.name.includes('Portal')) ? rand(0,1) : 0,
      pulled: 0
    });
  }

  // ======== PARTICLES + FLOATERS ========
  function pop(x,y, count, palette){
    for (let i=0;i<count;i++){
      state.particles.push({
        x, y,
        vx: rand(-45,45),
        vy: rand(-85,-25),
        g: rand(140, 210),
        t: 0,
        life: rand(0.25,0.55),
        c: palette ? palette[randi(0, palette.length-1)] : ['#ffffff','#89d6ff','#ff6aa6','#ffd35a','#56ff96'][randi(0,4)]
      });
    }
  }
  function floatText(x,y,msg,color){
    state.floaters.push({ x, y, msg, color, t:0, life:0.9, vy:-18 });
  }

  // ======== GAME FLOW ========
  function start(){
    state.running = true;
    state.paused = false;
    state.lastT = now();
    Audio.sfx('start');
  }
  function togglePause(){
    state.paused = !state.paused;
    if (!state.paused) { state.lastT = now(); Audio.sfx('start'); }
    else { Audio.sfx('pause'); }
  }
  function restart(){
    state.running = true;
    state.paused = false;
    state.lastT = now();
    state.tAlive = 0;

    state.score = 0;
    state.streak = 0;
    state.caught = 0;
    state.missed = 0;
    state.starving = 35;

    state.scraps.length = 0;
    state.particles.length = 0;
    state.floaters.length = 0;

    state.magnetTime = 0;
    state.slowTime = 0;
    state.dashTime = 0;
    state.dashCooldown = 0;
    state.slurpTime = 0;
    state.slurpCooldown = 0;
    state.slurpVfx = 0;

    resetGizmo();
    update.spawnT = 0;

    if (tilt.enabled) tilt.zeroSet = false; // re-calibrate on restart
    Audio.sfx('start');
  }
  function gameOver(){
    state.running = false;
    state.paused = true;
    state.best = Math.max(state.best, state.score);
    Audio.sfx('gameover');
  }

  // ======== BACKGROUND ========
  function drawBackground(){
    for (let y=0; y<BH; y++){
      const t = y/BH;
      const r = Math.round(10 + 40*t);
      const g = Math.round(18 + 60*t);
      const b = Math.round(35 + 90*t);
      bctx.fillStyle = `rgb(${r},${g},${b})`;
      bctx.fillRect(0,y,BW,1);
    }
    for (let x=0; x<BW; x+=10) pxFill(x, 0, 2, world.tableY-6, 'rgba(255,255,255,0.06)');

    // window
    pxFill(14, 14, 58, 34, '#0b1430');
    pxFill(16, 16, 54, 30, '#122a6a');
    state.twinkleT += 0.01;
    for (let i=0;i<18;i++){
      const sx = 18 + ((i*7 + 13) % 52);
      const sy = 18 + ((i*11 + 5) % 26);
      const on = (Math.sin(state.twinkleT + i*0.8) > 0.2);
      if (on) pxFill(sx, sy, 1, 1, '#eaf6ff');
    }
    outlineRect(14,14,58,34,'rgba(255,255,255,0.25)');
    pxFill(42,14,2,34,'rgba(255,255,255,0.18)');
    pxFill(14,31,58,2,'rgba(255,255,255,0.18)');

    // table
    const ty = world.tableY;
    pxFill(0, ty, BW, world.tableTopH, '#6b3b22');
    pxFill(0, ty+2, BW, 2, '#8f563b');
    pxFill(0, ty+world.tableTopH, BW, world.tableLipH, '#3a1f12');

    // legs
    const legY = ty+world.tableTopH+world.tableLipH;
    const legH = world.floorY() - legY + 6;
    pxFill(28, legY, 10, legH, '#4b2a18');
    pxFill(BW-38, legY, 10, legH, '#4b2a18');

    // floor
    const fy = world.floorY();
    pxFill(0, fy, BW, BH-fy, '#151a28');
    for (let y=fy; y<BH; y+=8){
      for (let x=0; x<BW; x+=8){
        const odd = ((x/8 + y/8) | 0) % 2;
        pxFill(x,y,8,8, odd ? '#141c2e' : '#101729');
      }
    }
    pxFill(0, fy, BW, 1, 'rgba(255,255,255,0.18)');
  }

  // ======== HUD ========
  function starvingColor(v){
    if (v < 45) return '#56ff96';
    if (v < 75) return '#ffd35a';
    return '#ff2b4f';
  }

  function drawHUD(){
    pxFill(0,0,BW,16,'rgba(0,0,0,0.35)');
    outlineRect(0,0,BW,16,'rgba(255,255,255,0.10)');

    const st = clamp(state.starving, 0, 100);
    const barW = 108;
    const barX = 6;
    const barY = 6;

    pxFill(barX-1, barY-1, barW+2, 7, 'rgba(0,0,0,0.40)');
    outlineRect(barX-1, barY-1, barW+2, 7, 'rgba(255,255,255,0.18)');
    pxFill(barX, barY, barW, 5, 'rgba(255,255,255,0.06)');
    pxFill(barX, barY, Math.round(barW * (st/100)), 5, starvingColor(st));

    const dash = state.dashCooldown > 0 ? `DASH:${state.dashCooldown.toFixed(0)}` : 'DASH:OK';
    const slrp = state.slurpCooldown > 0 ? `SLURP:${state.slurpCooldown.toFixed(0)}` : 'SLURP:OK';
    const tiltTxt = (isCoarse ? (tilt.enabled ? 'TILT:ON' : 'TILT:OFF') : '');
    const info = `STARV:${st.toFixed(0)}%  SCORE:${state.score}  STK:${state.streak}  ${dash} ${slrp} ${tiltTxt}`;
    pxText(info, 120, 4, 'rgba(234,246,255,0.92)');
  }

  // ======== OVERLAY (CENTERED + WRAPPED; FIXES CUT-OFF) ========
  function drawOverlay(){
    if (!state.running && state.paused) {
      const lines = [
        'GIZMO’S TABLE SCRAPS',
        `BEST: ${state.best}   LAST: ${state.score}`,
        isCoarse ? 'TILT TO MOVE. TAP ANYWHERE TO SLURP.' : 'ARROWS/A-D TO MOVE. X TO SLURP.',
        isCoarse ? 'TAP TO PLAY (ALLOW MOTION IF ASKED).' : 'SPACE TO PLAY.'
      ];
      const panel = drawCenteredPanel(lines, Math.floor(BH/2));
      // recolor title line a bit
      const title = panel.wrapped[0];
      pxText(title, Math.floor((BW - textW(title))/2), panel.y + 8, '#56ff96');
    } else if (state.paused) {
      const lines = ['PAUSED', isCoarse ? 'TAP ⏯ OR SPACE' : 'SPACE'];
      const panel = drawCenteredPanel(lines, Math.floor(BH/2));
      const title = panel.wrapped[0];
      pxText(title, Math.floor((BW - textW(title))/2), panel.y + 8, '#ffd35a');
    }
  }

  // ======== SLURP (TAP ANYWHERE ON CANVAS) ========
  function requestSlurp(){
    input.slurpPulse = true;
  }

  function applySlurp(dt){
    if (state.slurpTime <= 0) return;

    const radius = 56;
    const strength = 950;
    const cx = gizmo.x;
    const cy = gizmo.y + 6;

    state.slurpVfx = Math.max(state.slurpVfx, 0.20);

    for (const s of state.scraps) {
      const badMul = s.type.bad ? 0.55 : 1.0;

      const dx = cx - s.x;
      const dy = cy - s.y;
      const d = Math.max(1, Math.sqrt(dx*dx + dy*dy));
      if (d > radius) continue;

      const t = 1 - (d / radius);
      const accel = strength * (0.35 + 0.65*t) * badMul;

      s.vx += (dx / d) * accel * dt;
      s.vy += (dy / d) * accel * dt;

      s.pulled = 0.30;

      state.particles.push({
        x: s.x + rand(-1,1),
        y: s.y + rand(-1,1),
        vx: rand(-15,15),
        vy: rand(-10,10),
        g: 40,
        t: 0,
        life: 0.18,
        c: s.type.bad ? '#ff6aa6' : '#89d6ff'
      });

      if (d < 10 && !s.type.bad) {
        s.x += (dx / d) * 30 * dt;
        s.y += (dy / d) * 30 * dt;
      }
    }
  }

  function drawSlurpVfx(){
    if (state.slurpVfx <= 0) return;

    const x = gizmo.x|0;
    const y = (gizmo.y + 4)|0;
    const pulse = state.slurpVfx;
    const r = 10 + Math.round(pulse * 24);

    for (let i=0;i<12;i++){
      const a = (i/12) * Math.PI * 2;
      const px = x + Math.round(Math.cos(a) * r);
      const py = y + Math.round(Math.sin(a) * r);
      pxFill(px, py, 1, 1, 'rgba(137,214,255,0.30)');
    }

    const radius = 56;
    const cx = gizmo.x;
    const cy = gizmo.y + 6;
    let drawn = 0;

    for (const s of state.scraps) {
      const dx = cx - s.x;
      const dy = cy - s.y;
      const d2 = dx*dx + dy*dy;
      if (d2 > radius*radius) continue;
      if (drawn++ > 7) break;

      const steps = 5;
      for (let k=1;k<=steps;k++){
        const tt = k/(steps+1);
        const lx = Math.round(s.x + dx*tt);
        const ly = Math.round(s.y + dy*tt);
        pxFill(lx, ly, 1, 1, s.type.bad ? 'rgba(255,106,166,0.25)' : 'rgba(137,214,255,0.38)');
      }
    }
  }

  // ======== STARVING ========
  function starvationTick(dt){
    const comfort = clamp((60 - state.starving) / 60, 0, 1);
    const diff = clamp(1 + (state.tAlive/40) + comfort*0.8, 1, 4.0);
    const passive = (3.6 + diff*1.6) * dt;
    state.starving = clamp(state.starving + passive, 0, 100);

    if (state.starving >= 85) {
      state.dangerPulseT += dt;
      if (state.dangerPulseT >= 0.7) {
        state.dangerPulseT = 0;
        Audio.sfx('danger');
      }
    } else {
      state.dangerPulseT = 0;
    }
  }

  // ======== UPDATE ========
  function update(dt){
    state.tAlive += dt;

    // timers
    if (state.magnetTime > 0) state.magnetTime = Math.max(0, state.magnetTime - dt);
    if (state.slowTime > 0) state.slowTime = Math.max(0, state.slowTime - dt);
    if (state.dashTime > 0) state.dashTime = Math.max(0, state.dashTime - dt);
    if (state.dashCooldown > 0) state.dashCooldown = Math.max(0, state.dashCooldown - dt);
    if (state.slurpTime > 0) state.slurpTime = Math.max(0, state.slurpTime - dt);
    if (state.slurpCooldown > 0) state.slurpCooldown = Math.max(0, state.slurpCooldown - dt);
    if (state.slurpVfx > 0) state.slurpVfx = Math.max(0, state.slurpVfx - dt);

    starvationTick(dt);
    if (state.starving >= 100) { gameOver(); return; }

    // slow-time scaling
    const slowFactor = (state.slowTime > 0) ? 0.62 : 1.0;
    dt *= slowFactor;

    // dash trigger (mobile button or shift key)
    if (input.dash && state.dashCooldown <= 0 && state.dashTime <= 0) {
      state.dashTime = 0.25;
      state.dashCooldown = 1.25;
      Audio.sfx('dash');
    }

    // slurp trigger (tap/keyboard)
    if ((input.slurpPulse) && state.slurpCooldown <= 0 && state.slurpTime <= 0) {
      state.slurpTime = 0.55;
      state.slurpCooldown = 1.10;
      Audio.sfx('slurp');
      floatText(gizmo.x, gizmo.y - 18, 'SLURP!', '#89d6ff');
    }
    input.slurpPulse = false;

    // movement
    const dashMul = (state.dashTime > 0) ? 1.75 : 1.0;
    gizmo.bob += dt * (Math.abs(gizmo.vx) > 1 ? 8 : 3);

    let dir = 0;

    // Tilt (mobile Safari)
    if (isCoarse && tilt.enabled) {
      // deadzone + scaling
      const dead = 2.5;
      const v = (Math.abs(tilt.smooth) < dead) ? 0 : tilt.smooth;
      const tiltDir = clamp(v / 16, -1.25, 1.25); // ~16deg => full speed
      dir += tiltDir;
    }

    // Buttons/keys add on top
    dir += (input.left ? -1 : 0) + (input.right ? 1 : 0);
    dir = clamp(dir, -1.6, 1.6);

    if (!isCoarse && input.mode === 'pointer' && input.targetX != null) {
      const dx = input.targetX - gizmo.x;
      gizmo.vx = dx * 7 * dashMul;
    } else {
      gizmo.vx = dir * gizmo.speed * dashMul;
    }

    gizmo.x += gizmo.vx * dt;
    gizmo.x = clamp(gizmo.x, world.left()+10, world.right()-10);
    gizmo.mouth = Math.max(0, gizmo.mouth - dt*4);

    state.level = 1 + Math.floor(state.tAlive / 18);

    // spawning (easier when starving high)
    const starvingEase = clamp((state.starving - 40) / 60, 0, 1);
    const comfort = clamp((60 - state.starving) / 60, 0, 1);
    const diff = clamp(1 + (state.tAlive/35) + comfort*0.9, 1, 4.2);

    const baseEvery = clamp(0.62 - diff*0.10 + starvingEase*0.10, 0.26, 0.70);
    update.spawnT = (update.spawnT ?? 0) + dt;
    while (update.spawnT >= baseEvery) {
      update.spawnT -= baseEvery;
      spawnScrap();
      if (Math.random() < (0.04 + diff*0.02) && starvingEase < 0.8) spawnScrap();
    }

    // slurp physics
    applySlurp(dt);

    // scraps update + collision
    const fy = world.floorY();
    const catchW = 28, catchH = 18;
    const catchX = gizmo.x - catchW/2;
    const catchY = gizmo.y;

    for (let i=state.scraps.length-1; i>=0; i--){
      const s = state.scraps[i];

      // magnet assistance for good items
      const baseMag = 0.08;
      const powerMag = (state.magnetTime > 0) ? 0.40 : 0;
      const magStrength = baseMag + powerMag;

      if (!s.type.bad) {
        const pull = clamp((gizmo.x - s.x) * 0.8, -60, 60);
        s.vx += pull * magStrength * dt;
      }

      s.wT += dt * s.wob;
      s.x += s.vx * dt + Math.sin(s.wT) * 4 * dt;
      s.y += s.vy * dt;

      if (s.x < world.left()+8){ s.x = world.left()+8; s.vx *= -0.35; }
      if (s.x > world.right()-8){ s.x = world.right()-8; s.vx *= -0.35; }

      if (s.sparkle) s.sparkle = (s.sparkle + dt*3) % 1;
      if (s.pulled > 0) s.pulled = Math.max(0, s.pulled - dt);

      const sx = s.x|0, sy = s.y|0;

      // collision
      if (sx >= catchX && sx <= catchX+catchW && sy >= catchY && sy <= catchY+catchH) {
        state.scraps.splice(i,1);
        gizmo.mouth = 1;
        state.caught++;

        const streakTier = Math.min(4, Math.floor(state.streak / 6));
        if (s.type.bad) {
          state.streak = 0;
          state.score = Math.max(0, state.score + s.type.base);
          state.starving = clamp(state.starving + (10 + Math.abs(s.type.feed)), 0, 100);
          Audio.sfx('bad');
          pop(sx, sy, 18, ['#ff2b4f','#ff6aa6','#ffd35a']);
          floatText(sx, sy-8, `NOPE: ${s.type.name}`, '#ff6aa6');
        } else {
          state.streak += 1;

          const comboBonus = streakTier * 4;
          const pts = Math.max(1, s.type.base + comboBonus);
          state.score += pts;

          const feedBonus = 1.5 * streakTier;
          state.starving = clamp(state.starving - (s.type.feed + feedBonus), 0, 100);

          if (s.type.onCatch) s.type.onCatch();
          if (pts >= 30 || streakTier >= 3) Audio.sfx('bonus');
          else Audio.sfx('catch');

          pop(sx, sy, 12 + Math.floor(pts/9));
          floatText(sx, sy-8, `+${pts} ${s.type.name}`, '#eaf6ff');
        }

        if (state.starving >= 100) { gameOver(); return; }
        continue;
      }

      // miss
      if (s.y > fy + 10) {
        state.scraps.splice(i,1);
        state.missed++;
        if (state.streak > 0) state.streak = 0;

        const dangerEase = clamp((state.starving - 70)/30, 0, 1);
        const missBase = 7.0 + clamp(state.tAlive/50, 0, 3.0);
        const missBonus = (1 - dangerEase) * 2.5;
        state.starving = clamp(state.starving + missBase + missBonus, 0, 100);

        state.score = Math.max(0, state.score - 1);

        Audio.sfx('miss');
        pop(sx, fy, 10, ['#89d6ff','#eaf6ff','#56ff96']);
        if (state.starving >= 100) { gameOver(); return; }
      }
    }

    // particles
    for (let i=state.particles.length-1; i>=0; i--){
      const p = state.particles[i];
      p.t += dt;
      p.vy += p.g * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.t >= p.life) state.particles.splice(i,1);
    }

    // floaters
    for (let i=state.floaters.length-1; i>=0; i--){
      const f = state.floaters[i];
      f.t += dt;
      f.y += f.vy * dt;
      if (f.t >= f.life) state.floaters.splice(i,1);
    }
  }

  // ======== DRAW ========
  function drawScrap(s){
    const x = s.x|0, y = s.y|0;
    pxFill(x-3, y+4, 6, 1, 'rgba(0,0,0,0.25)');
    s.type.draw(x,y);

    if (s.sparkle) {
      const on = (s.sparkle < 0.33) || (s.sparkle > 0.66);
      if (on) { pxFill(x-7,y-6,1,1,'#fff2b0'); pxFill(x+6,y-2,1,1,'#fff2b0'); pxFill(x-2,y+6,1,1,'#fff2b0'); }
    }
    if (s.pulled > 0) {
      pxFill(x-6, y-6, 1, 1, 'rgba(137,214,255,0.75)');
      pxFill(x+6, y-4, 1, 1, 'rgba(86,255,150,0.75)');
    }
  }

  function drawParticles(){
    for (const p of state.particles){
      const a = 1 - (p.t / p.life);
      bctx.globalAlpha = Math.max(0, Math.min(1, a));
      pxFill(p.x|0, p.y|0, 2, 2, p.c);
    }
    bctx.globalAlpha = 1;
  }

  function drawFloaters(){
    for (const f of state.floaters){
      const a = 1 - (f.t / f.life);
      bctx.globalAlpha = Math.max(0, Math.min(1, a));
      pxText(f.msg, (f.x|0) - Math.floor(textW(f.msg)/2), f.y|0, f.color);
    }
    bctx.globalAlpha = 1;
  }

  function render(){
    bctx.clearRect(0,0,BW,BH);

    drawBackground();
    for (const s of state.scraps) drawScrap(s);
    drawParticles();
    drawSlurpVfx();
    drawGizmo();
    drawFloaters();
    drawHUD();
    drawOverlay();

    sctx.imageSmoothingEnabled = false;
    sctx.clearRect(0,0,window.innerWidth, window.innerHeight);
    sctx.drawImage(buf, 0, 0, BW, BH, ox, oy, BW*scale, BH*scale);
  }

  // ======== LOOP ========
  function loop(){
    requestAnimationFrame(loop);
    const t = now();
    let dt = (t - state.lastT)/1000;
    state.lastT = t;
    dt = Math.min(dt, 0.05);

    const active = (state.running && !state.paused);
    if (active) update(dt);
    render();
    if (Audio.ctx) Audio.tickMusic(active);
  }
  loop();

  // ======== CANVAS TAP BEHAVIOR (iOS): TAP = SLURP (WHEN PLAYING) ========
  screen.addEventListener('pointerdown', async (e) => {
    e.preventDefault();
    unlockAudioOnce();
    await requestTiltPermissionOnce();

    if (!state.running) {
      // calibrate tilt baseline right when starting to prevent drift
      if (tilt.enabled) tilt.zeroSet = false;
      start();
      return;
    }
    if (state.paused) {
      togglePause();
      return;
    }

    // Playing: tap anywhere to slurp
    requestSlurp();
  }, { passive:false });

  // ======== MOBILE BUTTONS ========
  function bindHoldButton(el, onDown, onUp) {
    const down = (ev) => { ev.preventDefault(); ev.stopPropagation(); unlockAudioOnce(); onDown(); };
    const up   = (ev) => { ev.preventDefault(); ev.stopPropagation(); onUp(); };
    el.addEventListener('pointerdown', down, { passive:false });
    el.addEventListener('pointerup', up, { passive:false });
    el.addEventListener('pointercancel', up, { passive:false });
    el.addEventListener('pointerleave', up, { passive:false });
  }

  document.querySelectorAll('[data-act]').forEach(btn => {
    const act = btn.getAttribute('data-act');
    if (act === 'left')  bindHoldButton(btn, () => { input.left = true; setKeysMode(); }, () => { input.left = false; });
    if (act === 'right') bindHoldButton(btn, () => { input.right = true; setKeysMode(); }, () => { input.right = false; });
    if (act === 'dash')  bindHoldButton(btn, () => { input.dash = true; setKeysMode(); }, () => { input.dash = false; });
    if (act === 'pause') {
      btn.addEventListener('pointerdown', async (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        unlockAudioOnce();
        await requestTiltPermissionOnce();
        if (!state.running) start();
        else togglePause();
      }, { passive:false });
    }
  });

})();
</script>
</body>
</html>
